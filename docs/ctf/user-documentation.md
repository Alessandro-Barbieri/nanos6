Introduction
============

The CTF instrumentation backend is a performance evaluation and debugging tool aimed for Nanos6 users and developers alike. Its purpose is to record the most relevant information of a Nanos6 execution efficiently and to provide means for visually inspecting it offline. The Nanos6 CTF backend is simple (no installation prerequisites) and mostly lock-free (see the section "Implementation details" for more information).

Nanos6 stores traces in the Common Trace Format (CTF). CTF traces can be directly visualized with tools such as babeltrace1 or babeltrace2 (raw command line inspector). But it is recommended first to convert them to Paraver traces using the provided ctf2prv application. Although Nanos6 requires no special packages to write CTF traces, the ctf2prv converter needs python3 and the babeltrace2 python bindings.

The Nanos6 CTF backend will transparently collect hardware counters information if the Nanos6 Hardware counters infrastructure has been enabled. See the Nanos6 README for more information on how to enable Hardware Counters.

This backend objective is not to replace Extrae, but to provide a minimum set of features for easy Nanos6 introspection. More sophisticated analysis (such as task dependency graphs) will have to be performed with Extrae as usual.

Implementation details
----------------------

Nanos6 keeps a per-core buffer to store CTF events before flushing them to the storage device. Therefore, events generated by Nanos6 Worker threads do not require to take a look. However, events triggered by a thread not directly controlled by Nanos6 share a buffer, and it is necessary to take a lock.

When a buffer is full, it is needed to flush it to the storage device. Flushing is done synchronously (i.e. a worker thread that generates a tracepoint will have to flush the buffer if there no free space left) and it might affect the execution workflow. Flushing operations are also recorded and can be inspected with the "CTF flush buffers to disk" view.

Traces are written by default under the TMPDIR environment variable or under /tmp if not set. Traces written to /tmp are kept in ram memory (see tmpfs for more information) and flushing translates to a memory copy operation. When an application execution finishes, Nanos6 copies the trace to the current directory.

Usage
=====

To generate a CTF trace:

```bash
NANOS6=ctf ./app
```

TODO add hwc example

This will create a trace-<app_name>-<app_pid> folder in the current directory. To convert it to paraver:

```bash
$NANOS6_SOURCE/tools/ctf/ctf2prv ./trace-<app_name>-<app_pid>
```

Paraver Views
=============

A number of paraver views are provided with each Nanos6 distribution under the directory:

 <NANOS6_INSTALL>/share/doc/nanos6/paraver-cfg/ctf2prv 

Do not use the extrae cfg's views as some event Ids are not compatible.


Tasks
-----

Shows the name (label) of tasks executed in each core.

It also displays the time spent on Nanos6 Runtime (shown as "Runtime") and threads busy waiting (shown as "busy wait") while waiting for ready tasks to execute.

Task source
-----------

Shows the source code location of tasks executed in each core.

It also displays the time spent on Nanos6 Runtime (shown as "Runtime") and threads busy waiting (shown as "busy wait") while waiting for ready tasks to execute.

Hardware Counters
-----------------

Shows the collected hardware counters (HWC) information. Please note that you must enable HWC collection in Nanos6 first. See Nanos6 documentation for more details.

The HWC information is collected per each task burst (a task executing without interruption such as blocking) and per also inside Nanos6 core code. By default, it displays PAPI_TOT_INS. Each HWC is displayed as a different Extrae Event. If you want to inspect another counter, please, modify the "Value to display" subview of the "Hardware Counters" view to display the appropriate Extrae Event (HWC event) under Paraver's "Filter->Events->Event Type->Types" menu.

Task Id
-------

Shows the unique id of the tasks executed in each core.

The default colouring of this view is "Not Null Gradient Color", which eases identifying the execution progress of tasks as they were created. The id's 0, 1, 2 and 3 are reserved for (Idle, Runtime, Busy Wait and Task respectively. Hence, it might be interesting to manually set the Paraver's "Semantic Minimum" value to 4, which will not include these values for the gradient colouring. This is the value by default, but if you perform a semantic adjustment, you will need to change the "Semantic Minimum" manually again.

It might also be interesting to draw this view as "Code Color" which will make it easier to spot different consecutive tasks. Under this colouring scheme, It is easier to see the time spent running Nanos6 core code shown as "Runtime" and when threads perform a "busy wait" while waiting for more tasks to execute.

Thread Id
---------

Shows the thread Id (TID) of the thread that was running in each core.

Be aware that this view only shows the thread placement according to Nanos6 perspective, not the OS perspective. This means that even if this view shows a thread running uninterruptedly in a core for a long time, the system might have preempted the Nanos6 thread by another system thread a number of times without this being displayed in the view.

Runtime Status Simple
---------------------

Shows the a simplified view of the runtime states.

It displays the time spent running Nanos6 core code shown as "Runtime", when threads perform a "busy wait" while waiting for more tasks to execute and when the runtime is running task's code shown as "Task".

Runtime Subsystems
------------------

Shows the activity of the most interesting Nanos6 subsystems. In essence, a coarse-grained classification of the time spent while running Nanos6 core code.

The displayed subsystems include: Task creation/initialization, dependency registration/unregistration, scheduling add/get tasks and polling services. 

Number of Blocked Tasks
-----------------------

Shows a graph of tasks in the blocked state.

Blocked tasks are tasks that started running at some point and then stopped running before completing. This might block, for instance, due to a taskwait directive.

Number of Running Tasks
-----------------------

Shows a graph of tasks being executed by some worker thread.


Number of Created Tasks
-----------------------

Shows a graph with the count of total created tasks.

A task is created when its Nanos6 data structures are allocated and registered within the Nanos6 core.


Number of Created Workers
-------------------------

Shows a graph of created worker threads by Nanos6.

Once a worker thread is created, it is not destroyed until the end of the application's execution.

Number of Running Workers
-------------------------

Shows a graph of Nanos6 worker threads that are allowed to run on a core.

Please note that even if Nanos6 allows a worker to run, another system thread might have temporarily preempted that worker. System preemptions are not displayed in this view.

Number of Blocked Workers
-------------------------

Shows a graph of worker threads that are blocked (no longer running), either because they are idle or because they are waiting for some event.

This view only counts workers that blocked due to Nanos6 will. If a worker that is running a task blocks because of a blocking operation performed by the task code (hence, outside the scope of Nanos6) it won't be shown in this view.

CTF flush buffers to disk
-------------------------

Eventually, the nanos6 buffers that hold the events are filled and need to be flushed to disk. When this happens, the application's execution might be altered because of the introduced overhead. This flushing can occur in a number of places within the nanos6 core, either because the buffers were completely full or because nanos6 decided to flush them before reaching that limit.

This view shows exactly when the flushing happened. If attempting to write the event A into the nanos6 event buffer triggers a flush, the produced nanos6 trace will first show the event that triggered the flush followed by the flushing events.
